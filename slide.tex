\documentclass[dvipdfmx,11pt]{beamer}

\usepackage{bm}
\usepackage[figurename=,tablename=]{caption}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage[yyyymmdd]{datetime}
\usepackage{url}
\usepackage{listings}
\usepackage{fancyvrb}

\usepackage{scheme}
\usepackage{rust}
\usepackage{ocaml}

\usepackage{catchfilebetweentags}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]{}
\setbeamerfont{footline}{size=\small}
\setbeamerfont{date}{size=\footnotesize}

% Use the same font in nested itemizes.
\setbeamerfont*{itemize/enumerate body}{}
\setbeamerfont*{itemize/enumerate subbody}{parent=itemize/enumerate body}
\setbeamerfont*{itemize/enumerate subsubbody}{parent=itemize/enumerate body}

% Change font
\renewcommand{\kanjifamilydefault}{\gtdefault}
\renewcommand{\dateseparator}{-}

\newtheorem{proposition}[theorem]{Proposition}

\input{local}

\title{クロージャについて}
\subtitle{RustのLT会！ Rust入門者の集い}
\author{樹下稔}
\date{2017/03/01}

\begin{document}

\maketitle

\begin{frame}{自己紹介}
  \begin{description}
  \item[なまえ] 樹下稔
  \item[twitter] @trigott
  \item[所属] KLab inc.
  \item[好きな言語] Agda, OCaml
  \end{description}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item Rust 歴はほんの少し
  \item もともと型の強い関数型言語が好きで、型推論やパターンマッチの使える Rust はなんとなく使えた
  \item 一方で Rust のシステムプログラミング言語としての？制約にぶつかることもあった
  \item クロージャは関数型言語では馴染みの深い概念だが、Rust で使う際には注意が必要という典型的な例だと感じたので、クロージャの話をします
  \item Rust は素人なので話は疑っていただけると
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{クロージャとは}
  \begin{itemize}
  \item 関数と関数中に現れる変数を評価するための環境の組
  \item SICP の銀行口座の例
  \end{itemize}

  \lstinputlisting[language=Scheme]{src/account.lisp}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item OCaml の場合、参照だけ扱いを変えて後はほぼそのまま
  \end{itemize}
  \lstinputlisting[language={OCaml}]{src/account_disp.ml}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item Rust の場合
  \end{itemize}
  \lstinputlisting[language={Rust}]{src/account_disp.rs}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item mut, FnMut, move, Box って何
  \item 簡単なパーツから始めて、説明していきます
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item 簡単な関数を返してみる
    \begin{lstlisting}[language={Rust}]
fn id_i32() -> i32 -> i32 {
    |x: i32| { x }
}
    \end{lstlisting}
  \item エラーになる
\begin{Verbatim}[fontsize=\scriptsize]
error: expected one of `!`, `(`, `::`, `<`, `where`, or `{`, found `->`
 --> account1.rs:2:24
  |
2 |     fn id_i32() -> i32 -> i32 {
  |                        ^^
\end{Verbatim}
  \item ???

  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item ドキュメントを読むと、クロージャの型は \verb+Fn+ という trait を実装していないといけないらしい
    \begin{itemize}
    \item なんかエラーメッセージ不親切な気が
    \end{itemize}
  \item とりあえず雰囲気で下のように書いてみる
    \begin{lstlisting}[language={Rust}]
fn id_i32() -> Fn(i32) -> i32 {
    |x: i32| { x }
}
    \end{lstlisting}
  \item エラーになる
\begin{Verbatim}[fontsize=\scriptsize]
error[E0308]: mismatched types
 --> account1.rs:7:9
  |
7 |         |x: i32| { x }
  |         ^^^^^^^^^^^^^^ expected trait std::ops::Fn, found closure
  |
  = note: expected type `std::ops::Fn(i32) -> i32 + 'static`
  = note:    found type `[closure@account1.rs:7:9: 7:23]`
\end{Verbatim}
  \item ???
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item クロージャの型はそれぞれ固有の型名がつくため、シグニチャの型と推論された型とでミスマッチが起きていると思われる
    \begin{itemize}
    \item 例えば、引数としてクロージャを受け取るときは、generics に trait 制約をつける形で型を書かないといけない
    \item \verb+>+ Because each closure generates its own environment struct and implementation of Fn and friends, these types are anonymous. They exist solely for this closure. So Rust shows them as \verb+closure@<anon>+, rather than some autogenerated name.
    \end{itemize}
  \item クロージャを返したい場合どうしたらいいか分からず...
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item 実はもう一つエラーが出ていたのでそちらに注目してみる
  \end{itemize}
  \begin{Verbatim}[fontsize=\scriptsize]
    error[E0277]: the trait bound
                  `std::ops::Fn(i32) -> i32 + 'static: std::marker::Sized`
                  is not satisfied
 --> account1.rs:6:20
  |
6 |     fn id_i32() -> Fn(i32) -> i32{
  |                    ^^^^^^^^^^^^^^
  |       the trait `std::marker::Sized` is not implemented for
  |       `std::ops::Fn(i32) -> i32 + 'static`
  |
  = note: `std::ops::Fn(i32) -> i32 + 'static` does not have a constant
          size known at compile-time
  = note: the return type of a function must have a statically known size
    \end{Verbatim}
  \begin{itemize}
  \item \verb+Fn(i32) -> i32+ は trait なので、複数の型の候補があり、型のサイズが分からない
  \item 返り値の型のサイズはコンパイル時に分かっている必要があるため、怒られている
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item Box を使う
    \begin{itemize}
    \item ヒープ領域へのポインタ型
    \item 参照なので型のサイズは一定
    \end{itemize}
    \begin{lstlisting}[language={Rust}]
fn id_i32() -> Box<Fn(i32) -> i32> {
   Box::new(|x: i32| { x })
}
    \end{lstlisting}
  \item できた!
    \begin{itemize}
    \item なぜか型チェック通る
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item そろそろ mut したい
    \begin{itemize}
      \item Rust の変数は基本 immutable、可変にしたいときは mut をつける
    \end{itemize}
    \begin{lstlisting}[language={Rust}]
fn make_adder() -> Box<Fn(i32) -> i32> {
    let mut acc = 0;
    Box::new(|x: i32| {
        acc += x;
        acc
    })
}
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item エラーになる
  \end{itemize}
  \begin{Verbatim}[fontsize=\scriptsize]
error[E0373]: closure may outlive the current function, but it borrows
              `acc`, which is owned by the current function
  --> account1.rs:16:18
   |
16 |         Box::new(|x: i32| {
   |                  ^^^^^^^^ may outlive borrowed value `acc`
17 |             acc += x;
   |             --- `acc` is borrowed here
   |
  \end{Verbatim}
  \begin{itemize}
  \item ウオアアアアアアア
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item 考えてみよう
  \end{itemize}

  \begin{lstlisting}[language={Rust}]
fn make_adder() -> Box<Fn(i32) -> i32> {
    let mut acc = 0;
    Box::new(|x: i32| {
        acc += x;
        acc
    })
}
let mut adder = make_adder()
println!("{:?}", adder(10))
  \end{lstlisting}

  \begin{itemize}
  \item \verb+acc+ の lifetime は \verb+make_adder+ の中身だけ
  \item \verb+make_adder+ の返すクロージャは \verb+make_adder+ の本体よりも長生きする
  \item \verb+make_adder+ の返すクロージャは \verb+acc+ を参照しているが \verb+make_adder+ の実行が終わったあとだとすでに \verb+acc+ は死んでいるため参照できない
  \end{itemize}

\end{frame}

\begin{frame}[fragile]

  \begin{Verbatim}[fontsize=\scriptsize]
help: to force the closure to take ownership of `acc` (and any other
      referenced variables), use the `move` keyword, as shown:
   |         Box::new(move |x: i32| {
  \end{Verbatim}

  \begin{itemize}
  \item 実は help が出ていたので、それに従い move を使う
    \begin{itemize}
    \item move を使うと環境中の変数の所有権を取得する
    \item クロージャに新しく環境を与えるとも考えられる
      \begin{itemize}
      \item 環境の作成を明示する必要がある
      \end{itemize}
    \end{itemize}
    \begin{lstlisting}[language={Rust}]
fn make_adder() -> Box<Fn(i32) -> i32> {
    let mut acc = 0;
    Box::new(move |x: i32| {
        acc += x;
        acc
    })
}
    \end{lstlisting}
  \item \verb+acc+ の所有権がクロージャの中身に移譲されるので、クロージャと \verb+acc+ の lifetime が一致する
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item ところでエラーです
  \end{itemize}

  \begin{Verbatim}[fontsize=\scriptsize]
error: cannot assign to captured outer variable in an `Fn` closure
  --> account1.rs:25:13
   |
25 |             acc += x;
   |             ^^^^^^^^
   |
  \end{Verbatim}

\end{frame}

\begin{frame}[fragile]
    \begin{lstlisting}[language={Rust}]
fn make_adder() -> Box<Fn(i32) -> i32> {
    let mut acc = 0;
    Box::new(move |x: i32| {
        acc += x;
        acc
    })
}
    \end{lstlisting}

  \begin{itemize}
  \item Fn という trait は環境中の変数を変更することができない
  \item 変更したい場合 FnMut を使う必要がある
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Fn について少し詳細}
  \begin{itemize}
  \item Fn という trait は「実行する」というメソッドを実装することを要求している
  \end{itemize}

  \begin{lstlisting}[language={Rust}]
pub trait Fn<Args> : FnMut<Args> {
    extern "rust-call"
      fn call(&self, args: Args) -> Self::Output;
}
  \end{lstlisting}

  \begin{itemize}
  \item \verb+&self+ としてクロージャ本体を受け取っていることに注意
    \begin{itemize}
    \item ただの参照なので、変更できない
    \end{itemize}
  \item FnMut の場合、\verb+&mut self+ としてクロージャを受け取っているため、環境を変更することが可能
  \end{itemize}

  \begin{lstlisting}[language={Rust}]
pub trait FnMut<Args> : FnOnce<Args> {
    extern "rust-call"
      fn call_mut(&mut self, args: Args)
        -> Self::Output;
}
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item 初期値はそのまま受け取る
  \item \verb+make_adder+ の返り値は mut でないといけないことに注意
  \end{itemize}
  \begin{lstlisting}[language={Rust}]
fn make_adder(init: i32) -> Box<FnMut(i32) -> i32> {
    let mut acc = init;
    Box::new(move |x: i32| {
        acc += x;
        acc
    })
}
let mut adder = make_adder(10);
println!("{:?}", adder(10));
  \end{lstlisting}  
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item というわけで完成（再掲）
  \end{itemize}
  \lstinputlisting[language={Rust}]{src/account_disp.rs}
\end{frame}

\begin{frame}[fragile]{感想}
  \begin{itemize}
  \item クロージャ+mut の合わせ技でハマりどころがかなり増えた印象
  \item 参考にするものは The Rust Programming Language だけでも理解できる
  \item help は便利だけどちゃんと考えたほうがいい
    \begin{itemize}
      \item そのほうが面白い
    \end{itemize}
  \end{itemize}
\end{frame}

\end{document}

